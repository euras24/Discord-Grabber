import asyncio
from typing import Optional, List
import aiohttp
import datetime
import discord
from discord import app_commands
import random
import os
import time
import socket
import base64

encoded_token = "TVRNME5EWTRNVEUxTnpjek1UWTRORE00TlEuR1cwMGpRLjRFVWJLXzF4YzVyM1hBbzN4TDVEY2hPaHhFdGY0cnJ3WGZMYzJR"
TOKEN = base64.b64decode(encoded_token).decode()

MAX_AMOUNT = 25
RANDOM_MIN_ID = 100000
RANDOM_MAX_ID = 10000000
MAX_ATTEMPTS = 400
CONCURRENT = 10
BATCH_DELAY = 0.12
MIN_RAP = 1
VERIFIED_ITEM_ID = 102611803
DATA_FILE = "data.txt"
COOLDOWN = 3.5

intents = discord.Intents.default()
client = discord.Client(intents=intents)
tree = app_commands.CommandTree(client)
user_cooldowns = {}

async def fetch_roblox_user(session: aiohttp.ClientSession, user_id: int) -> Optional[dict]:
    url = f'https://users.roblox.com/v1/users/{user_id}'
    try:
        async with session.get(url) as resp:
            if resp.status != 200:
                return None
            return await resp.json()
    except Exception:
        return None

async def fetch_user_rap(session: aiohttp.ClientSession, user_id: int) -> int:
    url = f'https://inventory.roblox.com/v1/users/{user_id}/assets/collectibles?limit=100'
    total_rap = 0
    try:
        async with session.get(url) as resp:
            if resp.status != 200:
                return 0
            data = await resp.json()
            for asset in data.get('data', []):
                rap = asset.get('recentAveragePrice', 0)
                total_rap += rap if rap else 0
        return total_rap
    except Exception:
        return 0

async def fetch_inventory(session: aiohttp.ClientSession, user_id: int) -> Optional[List[dict]]:
    url = f'https://inventory.roblox.com/v1/users/{user_id}/assets/collectibles?limit=100'
    try:
        async with session.get(url) as resp:
            if resp.status != 200:
                return None
            return (await resp.json()).get('data', [])
    except Exception:
        return None

async def get_account_status(session: aiohttp.ClientSession, user_id: int, is_banned: bool) -> str:
    statuses = []
    statuses.append("Banned" if is_banned else "Available")
    inventory = await fetch_inventory(session, user_id)
    if inventory is None:
        statuses.append("Private")
    else:
        verified = any(item.get('assetId') == VERIFIED_ITEM_ID for item in inventory)
        statuses.append("Verified" if verified else "Unverified")
    return f"{statuses[0]} **|** {statuses[1]}"

def save_to_file(user_id: int, username: str, created: str, status: str, rap: int):
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            lines = f.readlines()
            for line in lines:
                if line.startswith(str(user_id) + " "):
                    return
    line = f"{user_id} {username} {created} {status} RAP: {rap}\n"
    with open(DATA_FILE, "a", encoding="utf-8") as f:
        f.write(line)

async def find_accounts(amount: int, rap_only: bool, unverified_only: bool) -> List[dict]:
    found = []
    attempts = 0
    async with aiohttp.ClientSession() as session:
        while len(found) < amount and attempts < MAX_ATTEMPTS:
            batch_ids = [random.randint(RANDOM_MIN_ID, RANDOM_MAX_ID) for _ in range(CONCURRENT)]
            tasks = [fetch_roblox_user(session, uid) for uid in batch_ids]
            results = await asyncio.gather(*tasks)
            for res in results:
                if res and res.get('created'):
                    rap = await fetch_user_rap(session, res['id'])
                    if rap_only and rap < MIN_RAP:
                        continue
                    status = await get_account_status(session, res['id'], res.get('isBanned', False))
                    if unverified_only and "Unverified" not in status:
                        continue
                    try:
                        dt = datetime.datetime.fromisoformat(res['created'].replace('Z', '+00:00'))
                        created_str = dt.strftime('%Y-%m-%d')
                    except Exception:
                        created_str = res['created']
                    save_to_file(res['id'], res['name'], created_str, status, rap)
                    found.append({
                        'id': res.get('id'),
                        'name': res.get('name'),
                        'displayName': res.get('displayName') or res.get('name'),
                        'created': created_str,
                        'status': status,
                        'rap': rap
                    })
                    if len(found) >= amount:
                        break
            attempts += CONCURRENT
            await asyncio.sleep(BATCH_DELAY)
    return found

@tree.command(name='look', description='Find Roblox OG accounts by type')
@app_commands.describe(amount='How many accounts to return (1-25)', type='Choose random, rap, or unverified accounts')
@app_commands.choices(type=[
    app_commands.Choice(name='random', value='random'),
    app_commands.Choice(name='rap', value='rap'),
    app_commands.Choice(name='unverified', value='unverified')
])
async def look_command(interaction: discord.Interaction, amount: int, type: app_commands.Choice[str]):
    now = time.time()
    user_id = interaction.user.id
    last_used = user_cooldowns.get(user_id, 0)
    remaining = COOLDOWN - (now - last_used)
    if remaining > 0:
        embed = discord.Embed(
            description=f"<@{user_id}> Please wait **{remaining:.1f}** seconds",
            color=0xFF0000
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return
    user_cooldowns[user_id] = now
    amount = max(1, min(MAX_AMOUNT, amount))
    await interaction.response.send_message('Searching...', ephemeral=False)
    rap_only = type.value == 'rap'
    unverified_only = type.value == 'unverified'
    accounts = await find_accounts(amount, rap_only, unverified_only)
    if not accounts:
        await interaction.edit_original_response(content='No accounts found.')
        return
    embed = discord.Embed(
        title=f'Found {len(accounts)} OG account{"s" if len(accounts) > 1 else ""}',
        description=f'Requested by <@{interaction.user.id}>',
        color=0xFFFFFF,
        timestamp=datetime.datetime.utcnow()
    )
    for a in accounts:
        name_line = f'`{a["displayName"]}` {a["status"]}'
        value = f'ID: {a["id"]} | Created: {a["created"]} | **RAP:** *`{a["rap"]}`*'
        embed.add_field(name=name_line, value=value, inline=False)
    await interaction.edit_original_response(content=None, embed=embed)

@client.event
async def on_ready():
    print(f'Logged in as {client.user} (ID: {client.user.id})')
    try:
        await tree.sync()
        print('Slash commands synced.')
    except Exception as e:
        print('Failed to sync commands:', e)
    desktop_name = socket.gethostname()
    activity = discord.Activity(
        type=discord.ActivityType.playing,
        name=f"on {desktop_name}"
    )
    await client.change_presence(status=discord.Status.dnd, activity=activity)

if __name__ == '__main__':
    if not os.path.exists(DATA_FILE):
        open(DATA_FILE, "w").close()
    client.run(TOKEN)
